<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>iCloud Album Viewer</title>

    <!-- Favicon -->
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon_32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon_16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="shortcut icon" href="/favicon.ico">
    
    <!-- Open Graph / Social Media Meta Tags -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="iCloud Viewer">
    <meta property="og:description" content="View and download photos from shared iCloud albums. Paste a link and browse your photos in a beautiful, fast interface.">
    <meta property="og:image" content="/og-image.png">
    <meta property="og:url" content="https://icloudviewer.com">
    
    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="iCloud Viewer">
    <meta name="twitter:description" content="View and download photos from shared iCloud albums">
    <meta name="twitter:image" content="/og-image.png">
    
    <!-- Additional Meta Tags -->
    <meta name="description" content="View and download photos from shared iCloud albums. Paste a link and browse your photos in a beautiful, fast interface.">
    <meta name="theme-color" content="#007AFF">
    
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Inter', 'Segoe UI', Roboto, sans-serif;
            min-height: 100vh;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        body.light {
            background-color: #ffffff;
            color: #1d1d1f;
        }

        body.dark {
            background-color: #000000;
            color: #f5f5f7;
        }

        #root {
            width: 100%;
            min-height: 100vh;
        }

        .fade-out {
            opacity: 0;
            transform: scale(0.98);
            transition: opacity 0.4s ease, transform 0.4s ease;
            pointer-events: none;
        }

        .skeleton {
            background: linear-gradient(90deg, #e8e8e8 25%, #f5f5f5 50%, #e8e8e8 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
        }

        .dark .skeleton {
            background: linear-gradient(90deg, #1c1c1e 25%, #2c2c2e 50%, #1c1c1e 75%);
            background-size: 200% 100%;
        }

        @keyframes shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes scaleIn {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.8);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        @keyframes quickFadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        @keyframes swipeOutLeft {
            0% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
            70% {
                opacity: 1;
            }
            100% {
                transform: translate(calc(-50% - 100vw), -50%) scale(0.9);
                opacity: 0;
            }
        }

        @keyframes swipeOutRight {
            0% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
            70% {
                opacity: 1;
            }
            100% {
                transform: translate(calc(-50% + 100vw), -50%) scale(0.9);
                opacity: 0;
            }
        }

        @keyframes swipeInFromRight {
            0% {
                transform: translate(calc(-50% + 100vw), -50%) scale(0.9);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }

        @keyframes swipeInFromLeft {
            0% {
                transform: translate(calc(-50% - 100vw), -50%) scale(0.9);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }

        .swipe-out-left {
            animation: swipeOutLeft 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
        }

        .swipe-out-right {
            animation: swipeOutRight 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
        }

        .swipe-in-from-right {
            animation: swipeInFromRight 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
        }

        .swipe-in-from-left {
            animation: swipeInFromLeft 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
        }

        .fade-in {
            animation: fadeIn 0.3s ease forwards;
        }

        .scale-in {
            animation: scaleIn 0.35s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
        }

        .quick-fade-in {
            animation: quickFadeIn 0.2s ease forwards;
        }

        .photo-card:hover .thumbnail-download {
            opacity: 1 !important;
        }

        .download-menu-item:hover {
            background: rgba(0, 122, 255, 0.1) !important;
        }

        .loading-dots {
            display: inline-flex;
            gap: 2px;
        }

        .loading-dots span {
            animation: dotFade 1.4s ease-in-out infinite;
        }

        .loading-dots span:nth-child(2) {
            animation-delay: 0.2s;
        }

        .loading-dots span:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes dotFade {
            0%, 100% { opacity: 0.2; }
            50% { opacity: 1; }
        }

        @keyframes dotPulse {
            0%, 100% { opacity: 0.2; }
            50% { opacity: 1; }
        }

        .loading-spinner {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 48px;
            height: 48px;
            position: relative;
        }

        .loading-spinner span {
            position: absolute;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            animation: dotPulse 1.6s ease-in-out infinite;
        }

        .loading-spinner span:nth-child(1) {
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            animation-delay: 0s;
        }

        .loading-spinner span:nth-child(2) {
            top: 6px;
            right: 6px;
            animation-delay: 0.2s;
        }

        .loading-spinner span:nth-child(3) {
            top: 50%;
            right: 0;
            transform: translateY(-50%);
            animation-delay: 0.4s;
        }

        .loading-spinner span:nth-child(4) {
            bottom: 6px;
            right: 6px;
            animation-delay: 0.6s;
        }

        .loading-spinner span:nth-child(5) {
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            animation-delay: 0.8s;
        }

        .loading-spinner span:nth-child(6) {
            bottom: 6px;
            left: 6px;
            animation-delay: 1s;
        }

        .loading-spinner span:nth-child(7) {
            top: 50%;
            left: 0;
            transform: translateY(-50%);
            animation-delay: 1.2s;
        }

        .loading-spinner span:nth-child(8) {
            top: 6px;
            left: 6px;
            animation-delay: 1.4s;
        }

        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 4px;
            border-radius: 2px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #007aff;
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #007aff;
            cursor: pointer;
            border: none;
        }
    </style>
</head>
<body class="light">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Icons
        const Sun = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <circle cx="12" cy="12" r="4"/>
                <path d="M12 2v2"/>
                <path d="M12 20v2"/>
                <path d="m4.93 4.93 1.41 1.41"/>
                <path d="m17.66 17.66 1.41 1.41"/>
                <path d="M2 12h2"/>
                <path d="M20 12h2"/>
                <path d="m6.34 17.66-1.41 1.41"/>
                <path d="m19.07 4.93-1.41 1.41"/>
            </svg>
        );

        const Moon = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"/>
            </svg>
        );

        const Plus = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <line x1="12" y1="5" x2="12" y2="19"/>
                <line x1="5" y1="12" x2="19" y2="12"/>
            </svg>
        );

        const Minus = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <line x1="5" y1="12" x2="19" y2="12"/>
            </svg>
        );

        const ArrowLeft = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="m12 19-7-7 7-7"/>
                <path d="M19 12H5"/>
            </svg>
        );

        const Download = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                <polyline points="7 10 12 15 17 10"/>
                <line x1="12" y1="15" x2="12" y2="3"/>
            </svg>
        );

        const Play = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="currentColor" stroke="none">
                <polygon points="5 3 19 12 5 21 5 3"/>
            </svg>
        );

        const CalendarArrowDown = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="m14 18 4 4 4-4"/>
                <path d="M16 2v4"/>
                <path d="M18 14v8"/>
                <path d="M21 11.354V6a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h7.343"/>
                <path d="M3 10h18"/>
                <path d="M8 2v4"/>
            </svg>
        );

        const CalendarArrowUp = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="m14 18 4-4 4 4"/>
                <path d="M16 2v4"/>
                <path d="M18 22v-8"/>
                <path d="M21 11.343V6a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h7.343"/>
                <path d="M3 10h18"/>
                <path d="M8 2v4"/>
            </svg>
        );

        const Loader = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M21 12a9 9 0 1 1-6.219-8.56"/>
            </svg>
        );

        const ChevronDown = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <polyline points="6 9 12 15 18 9"/>
            </svg>
        );

        const Camera = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"/>
                <circle cx="12" cy="13" r="3"/>
            </svg>
        );

        const ExternalLink = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"/>
                <polyline points="15 3 21 3 21 9"/>
                <line x1="10" y1="14" x2="21" y2="3"/>
            </svg>
        );

        const Video = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="m16 13 5.223 3.482a.5.5 0 0 0 .777-.416V7.87a.5.5 0 0 0-.752-.432L16 10.5"/>
                <rect x="2" y="6" width="14" height="12" rx="2"/>
            </svg>
        );

        const Server = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <rect width="20" height="8" x="2" y="2" rx="2" ry="2"/>
                <rect width="20" height="8" x="2" y="14" rx="2" ry="2"/>
                <line x1="6" x2="6.01" y1="6" y2="6"/>
                <line x1="6" x2="6.01" y1="18" y2="18"/>
            </svg>
        );

        const ListFilter = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M3 6h18"/>
                <path d="M7 12h10"/>
                <path d="M10 18h4"/>
            </svg>
        );

        const Users = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/>
                <circle cx="9" cy="7" r="4"/>
                <path d="M22 21v-2a4 4 0 0 0-3-3.87"/>
                <path d="M16 3.13a4 4 0 0 1 0 7.75"/>
            </svg>
        );

        const Check = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <polyline points="20 6 9 17 4 12"/>
            </svg>
        );

        const ICloudAlbumViewer = () => {
            const [albumUrl, setAlbumUrl] = useState('');
            const [loading, setLoading] = useState(false);
            const [photos, setPhotos] = useState([]);
            const [loadedPhotos, setLoadedPhotos] = useState({});
            const [error, setError] = useState('');
            const [albumInfo, setAlbumInfo] = useState(null);
            const [showLanding, setShowLanding] = useState(true);
            const [darkMode, setDarkMode] = useState(false);
            const [columns, setColumns] = useState(6);
            const [selectedPhoto, setSelectedPhoto] = useState(null);
            const [sortOrder, setSortOrder] = useState('newest');
            const [videoDurations, setVideoDurations] = useState({});
            const [copiedUrl, setCopiedUrl] = useState(false);

            // Calculate grid padding based on approximate square size
            const getGridPadding = () => {
                // Estimate square size: viewport width / columns
                const approxSquareSize = (typeof window !== 'undefined' ? window.innerWidth : 1200) / columns;
                
                if (approxSquareSize < 32) return '1px';
                if (approxSquareSize < 72) return '2px';
                return '4px';
            };

            // Calculate approximate square size for conditional rendering
            const getSquareSize = () => {
                return (typeof window !== 'undefined' ? window.innerWidth : 1200) / columns;
            };

            const [gridPadding, setGridPadding] = useState(getGridPadding());
            const [squareSize, setSquareSize] = useState(getSquareSize());
            const [swipeDirection, setSwipeDirection] = useState(null); // 'left' or 'right'
            const [isAnimating, setIsAnimating] = useState(false);
            const [previousPhoto, setPreviousPhoto] = useState(null);
            const [overlayLoadedPhotos, setOverlayLoadedPhotos] = useState({});
            const videoRef = useRef(null);
            const downloadMenuRef = useRef(null);
            const [showDownloadMenu, setShowDownloadMenu] = useState(false);
            const [isDownloading, setIsDownloading] = useState(false);
            const [isOpeningFromGrid, setIsOpeningFromGrid] = useState(false);
            const [showFilterMenu, setShowFilterMenu] = useState(false);
            const [selectedMediaTypes, setSelectedMediaTypes] = useState(new Set()); // empty = show all
            const [selectedContributors, setSelectedContributors] = useState(new Set());
            const [contributors, setContributors] = useState([]);
            const filterMenuRef = useRef(null);

            // Update grid padding and square size when columns change
            useEffect(() => {
                setGridPadding(getGridPadding());
                setSquareSize(getSquareSize());
            }, [columns]);

            // Update grid padding and square size on window resize
            useEffect(() => {
                const handleResize = () => {
                    setGridPadding(getGridPadding());
                    setSquareSize(getSquareSize());
                };
                
                window.addEventListener('resize', handleResize);
                return () => window.removeEventListener('resize', handleResize);
            }, [columns]);

            // Format duration in mm:ss
            const formatDuration = (seconds) => {
                if (!seconds) return null;
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            };

            // Sort and filter photos based on current sort order and filters
            const sortedPhotos = React.useMemo(() => {
                if (!photos.length) return photos;
                
                let filtered = [...photos];
                
                // Filter by media type (if any are selected)
                if (selectedMediaTypes.size > 0) {
                    filtered = filtered.filter(p => {
                        if (selectedMediaTypes.has('images') && !p.isVideo) return true;
                        if (selectedMediaTypes.has('videos') && p.isVideo) return true;
                        return false;
                    });
                }
                
                // Filter by contributors
                if (selectedContributors.size > 0) {
                    filtered = filtered.filter(p => 
                        p.contributorFullName && selectedContributors.has(p.contributorFullName)
                    );
                }
                
                // Sort by date
                return filtered.sort((a, b) => {
                    const dateA = a.dateCreated || a.batchDateCreated || '0';
                    const dateB = b.dateCreated || b.batchDateCreated || '0';
                    return sortOrder === 'newest' 
                        ? dateB.localeCompare(dateA)
                        : dateA.localeCompare(dateB);
                });
            }, [photos, sortOrder, selectedMediaTypes, selectedContributors]);

            // Calculate image and video counts from ALL photos (not filtered)
            const imageCount = React.useMemo(() => {
                return photos.filter(p => !p.isVideo).length;
            }, [photos]);

            const videoCount = React.useMemo(() => {
                return photos.filter(p => p.isVideo).length;
            }, [photos]);

            useEffect(() => {
                document.body.className = darkMode ? 'dark' : 'light';
            }, [darkMode]);


            useEffect(() => {
                const token = getTokenFromHash();
                if (token) {
                    const albumLink = `https://www.icloud.com/sharedalbum/#${token}`;
                    setAlbumUrl(albumLink);
                    fetchAlbumData(albumLink);
                }
            }, []);


            // Load video durations by creating hidden video elements
            useEffect(() => {
                if (photos.length === 0) return;
                
                const videos = photos.filter(p => p.isVideo && p.videoUrl);
                videos.forEach(video => {
                    if (videoDurations[video.id]) return;
                    
                    const videoEl = document.createElement('video');
                    videoEl.preload = 'metadata';
                    videoEl.src = video.videoUrl;
                    videoEl.onloadedmetadata = () => {
                        setVideoDurations(prev => ({
                            ...prev,
                            [video.id]: videoEl.duration
                        }));
                    };
                });
            }, [photos]);

            // Keyboard navigation for overlay
            useEffect(() => {
                if (!selectedPhoto) return;

                const handleKeyDown = (e) => {
                    if (isAnimating) return; // Prevent navigation during animation
                    
                    const currentIndex = sortedPhotos.findIndex(p => p.id === selectedPhoto.id);
                    
                    if (e.key === 'ArrowLeft' && currentIndex > 0) {
                        setIsAnimating(true);
                        setSwipeDirection('right'); // Left arrow = previous = swipe right
                        setPreviousPhoto(selectedPhoto);
                        setTimeout(() => {
                            setSelectedPhoto(sortedPhotos[currentIndex - 1]);
                            setTimeout(() => {
                                setSwipeDirection(null);
                                setPreviousPhoto(null);
                                setIsAnimating(false);
                            }, 400); // Match animation duration
                        }, 50);
                    } else if (e.key === 'ArrowRight' && currentIndex < sortedPhotos.length - 1) {
                        setIsAnimating(true);
                        setSwipeDirection('left'); // Right arrow = next = swipe left
                        setPreviousPhoto(selectedPhoto);
                        setTimeout(() => {
                            setSelectedPhoto(sortedPhotos[currentIndex + 1]);
                            setTimeout(() => {
                                setSwipeDirection(null);
                                setPreviousPhoto(null);
                                setIsAnimating(false);
                            }, 400); // Match animation duration
                        }, 50);
                    } else if (e.key === 'Escape') {
                        setSelectedPhoto(null);
                    }
                };

                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [selectedPhoto, sortedPhotos, isAnimating]);

            // Touch swipe navigation for overlay
            useEffect(() => {
                if (!selectedPhoto) return;

                let touchStartX = 0;
                let touchEndX = 0;
                const minSwipeDistance = 50; // minimum distance for a swipe

                const handleTouchStart = (e) => {
                    touchStartX = e.changedTouches[0].screenX;
                };

                const handleTouchEnd = (e) => {
                    touchEndX = e.changedTouches[0].screenX;
                    handleSwipe();
                };

                const handleSwipe = () => {
                    if (isAnimating) return; // Prevent swipe during animation
                    
                    const swipeDistance = touchStartX - touchEndX;
                    const currentIndex = sortedPhotos.findIndex(p => p.id === selectedPhoto.id);

                    // Swipe left (next photo)
                    if (swipeDistance > minSwipeDistance && currentIndex < sortedPhotos.length - 1) {
                        setIsAnimating(true);
                        setSwipeDirection('left');
                        setPreviousPhoto(selectedPhoto);
                        setTimeout(() => {
                            setSelectedPhoto(sortedPhotos[currentIndex + 1]);
                            setTimeout(() => {
                                setSwipeDirection(null);
                                setPreviousPhoto(null);
                                setIsAnimating(false);
                            }, 400); // Match animation duration
                        }, 50);
                    }
                    // Swipe right (previous photo)
                    else if (swipeDistance < -minSwipeDistance && currentIndex > 0) {
                        setIsAnimating(true);
                        setSwipeDirection('right');
                        setPreviousPhoto(selectedPhoto);
                        setTimeout(() => {
                            setSelectedPhoto(sortedPhotos[currentIndex - 1]);
                            setTimeout(() => {
                                setSwipeDirection(null);
                                setPreviousPhoto(null);
                                setIsAnimating(false);
                            }, 400); // Match animation duration
                        }, 50);
                    }
                };

                window.addEventListener('touchstart', handleTouchStart);
                window.addEventListener('touchend', handleTouchEnd);

                return () => {
                    window.removeEventListener('touchstart', handleTouchStart);
                    window.removeEventListener('touchend', handleTouchEnd);
                };
            }, [selectedPhoto, sortedPhotos, isAnimating]);

            // Autoplay video when loaded and animation completes
            useEffect(() => {
                if (selectedPhoto?.isVideo && 
                    overlayLoadedPhotos[selectedPhoto.id] && 
                    !swipeDirection && 
                    videoRef.current) {
                    videoRef.current.play().catch(err => {
                        // Autoplay failed (browser policy), user will need to click play
                        console.log('Autoplay prevented:', err);
                    });
                }
            }, [selectedPhoto, overlayLoadedPhotos, swipeDirection]);

            // Track if opening from grid (not navigating)
            useEffect(() => {
                if (selectedPhoto && !previousPhoto && !swipeDirection) {
                    setIsOpeningFromGrid(true);
                    // Reset after animation completes
                    setTimeout(() => {
                        setIsOpeningFromGrid(false);
                    }, 400);
                }
            }, [selectedPhoto]);

            // Close download menu when clicking outside
            useEffect(() => {
                if (!showDownloadMenu) return;

                const handleClickOutside = (e) => {
                    if (downloadMenuRef.current && !downloadMenuRef.current.contains(e.target)) {
                        setShowDownloadMenu(false);
                    }
                };

                // Use timeout to avoid closing immediately on the same click that opened it
                setTimeout(() => {
                    document.addEventListener('click', handleClickOutside);
                }, 0);
                
                return () => document.removeEventListener('click', handleClickOutside);
            }, [showDownloadMenu]);

            // Extract unique contributors from photos
            useEffect(() => {
                if (photos.length > 0) {
                    const contributorSet = new Set();
                    photos.forEach(photo => {
                        if (photo.contributorFullName) {
                            contributorSet.add(photo.contributorFullName);
                        }
                    });
                    setContributors(Array.from(contributorSet).sort());
                }
            }, [photos]);

            // Close filter menu when clicking outside
            useEffect(() => {
                if (!showFilterMenu) return;

                const handleClickOutside = (e) => {
                    if (filterMenuRef.current && !filterMenuRef.current.contains(e.target)) {
                        setShowFilterMenu(false);
                    }
                };

                setTimeout(() => {
                    document.addEventListener('click', handleClickOutside);
                }, 0);
                
                return () => document.removeEventListener('click', handleClickOutside);
            }, [showFilterMenu]);

            const getApiUrl = () => {
                if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
                    return 'http://localhost:3001';
                }
                return '';
            };

            const handleOverlayImageLoad = (photoId) => {
                setOverlayLoadedPhotos(prev => ({ ...prev, [photoId]: true }));
            };

            // Calculate placeholder dimensions based on photo aspect ratio
            const getPlaceholderDimensions = (photo) => {
                if (!photo || !photo.width || !photo.height) {
                    return { width: '60vw', height: '60vh' };
                }
                
                const aspectRatio = photo.width / photo.height;
                const maxWidth = window.innerWidth * 0.9;
                const maxHeight = window.innerHeight * 0.85;
                
                let width, height;
                
                if (aspectRatio > maxWidth / maxHeight) {
                    // Width-constrained
                    width = maxWidth;
                    height = width / aspectRatio;
                } else {
                    // Height-constrained
                    height = maxHeight;
                    width = height * aspectRatio;
                }
                
                return {
                    width: `${width}px`,
                    height: `${height}px`
                };
            };

            const extractAlbumToken = (url) => {
                // If it's already just a token (no # or /), return it
                if (/^[A-Za-z0-9]+$/.test(url.trim())) {
                    return url.trim();
                }
                // Otherwise extract from URL with #
                const match = url.match(/#([A-Za-z0-9]+)/);
                return match ? match[1] : null;
            };


            const getTokenFromHash = () => {
                const hash = window.location.hash;
                return hash && hash.length > 1 ? hash.substring(1) : null;
            };

            const updateHashFromUrl = (url) => {
                const token = extractAlbumToken(url);
                if (token) {
                    window.location.hash = token;
                }
            };

            // Copy current URL to clipboard
            const copyUrlToClipboard = async () => {
                try {
                    await navigator.clipboard.writeText(window.location.href);
                    setCopiedUrl(true);
                    setTimeout(() => setCopiedUrl(false), 2000);
                } catch (err) {
                    console.error('Failed to copy URL:', err);
                }
            };


            const fetchAlbumData = async (url) => {
                setShowLanding(false);
                setLoading(true);
                setError('');
                setPhotos([]);
                setLoadedPhotos({});
                setAlbumInfo(null);

                try {
                    const token = extractAlbumToken(url);
                    if (!token) {
                        throw new Error('Invalid iCloud album URL format');
                    }

                    const apiUrl = getApiUrl();
                    const response = await fetch(`${apiUrl}/api/album/${token}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });

                    if (!response.ok) {
                        throw new Error('Failed to fetch album data');
                    }

                    const data = await response.json();
                    
                    if (data.photos && data.photos.length > 0) {
                        const videoCount = data.photos.filter(p => p.mediaAssetType === 'video').length;
                        const photoCount = data.photos.length - videoCount;
                        setAlbumInfo({
                            name: data.streamName || 'Shared Album',
                            photoCount: photoCount,
                            videoCount: videoCount,
                            totalCount: data.photos.length
                        });

                        const photoList = data.photos.map(photo => {
                            const derivatives = photo.derivatives || {};
                            const sortedKeys = Object.keys(derivatives).sort((a, b) => {
                                const aWidth = parseInt(derivatives[a].width) || 0;
                                const bWidth = parseInt(derivatives[b].width) || 0;
                                return aWidth - bWidth;
                            });
                            
                            let thumbnailUrl = null;
                            let fullUrl = null;
                            let videoUrl = null;
                            
                            if (photo.mediaAssetType === 'video' && derivatives['PosterFrame']?.url) {
                                thumbnailUrl = derivatives['PosterFrame'].url;
                            }
                            
                            for (const key of sortedKeys) {
                                const d = derivatives[key];
                                if (d.url) {
                                    if (!thumbnailUrl) thumbnailUrl = d.url;
                                    fullUrl = d.url;
                                }
                            }
                            
                            // For videos, get the actual video URL (not poster frame)
                            if (photo.mediaAssetType === 'video') {
                                // Look for video derivatives (usually 720p, 360p, etc.)
                                for (const key of sortedKeys) {
                                    const d = derivatives[key];
                                    if (d.url && key !== 'PosterFrame') {
                                        videoUrl = d.url;
                                    }
                                }
                            }

                            return {
                                id: photo.photoGuid,
                                thumbnail: thumbnailUrl,
                                fullUrl: fullUrl,
                                videoUrl: videoUrl,
                                caption: photo.caption || '',
                                dateCreated: photo.dateCreated,
                                batchDateCreated: photo.batchDateCreated,
                                isVideo: photo.mediaAssetType === 'video',
                                duration: photo.duration ? parseFloat(photo.duration) : null,
                                width: parseInt(photo.width) || 1,
                                height: parseInt(photo.height) || 1,
                                contributorFullName: photo.contributorFullName || null,
                                contributorFirstName: photo.contributorFirstName || null,
                                contributorLastName: photo.contributorLastName || null
                            };
                        }).filter(p => p.thumbnail);

                        // Sort by date (newest first by default)
                        photoList.sort((a, b) => {
                            const dateA = a.dateCreated || a.batchDateCreated || '0';
                            const dateB = b.dateCreated || b.batchDateCreated || '0';
                            return dateB.localeCompare(dateA);
                        });

                        setPhotos(photoList);
                    } else {
                        throw new Error('No photos found in this album');
                    }
                } catch (err) {
                    setError(err.message || 'Failed to load album');
                    setShowLanding(true);
                } finally {
                    setLoading(false);
                }
            };

            const handleSubmit = (e) => {
                e.preventDefault();
                if (!albumUrl.trim()) return;
                updateHashFromUrl(albumUrl);
                fetchAlbumData(albumUrl);
            };

            const handleImageLoad = (photoId) => {
                setLoadedPhotos(prev => ({ ...prev, [photoId]: true }));
            };

            const downloadImage = async (photo, e) => {
                e?.stopPropagation();
                try {
                    // Use videoUrl for videos, fullUrl for images
                    const mediaUrl = photo.isVideo 
                        ? (photo.videoUrl || photo.fullUrl) 
                        : (photo.fullUrl || photo.thumbnail);
                    
                    const filename = `${photo.isVideo ? 'video' : 'photo'}-${photo.id}.${photo.isVideo ? 'mp4' : 'jpg'}`;
                    
                    // Use server proxy to bypass CORS
                    const apiUrl = getApiUrl();
                    const proxyUrl = `${apiUrl}/api/download?url=${encodeURIComponent(mediaUrl)}&filename=${encodeURIComponent(filename)}`;
                    
                    // Create a link and trigger download
                    const a = document.createElement('a');
                    a.href = proxyUrl;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                } catch (err) {
                    console.error('Download failed:', err);
                }
            };

            const downloadBulk = async (type) => {
                setShowDownloadMenu(false);
                setIsDownloading(true);

                try {
                    const zip = new JSZip();
                    const apiUrl = getApiUrl();
                    
                    // Filter photos based on type
                    let photosToDownload = [];
                    if (type === 'images') {
                        photosToDownload = sortedPhotos.filter(p => !p.isVideo);
                    } else if (type === 'videos') {
                        photosToDownload = sortedPhotos.filter(p => p.isVideo);
                    } else {
                        photosToDownload = sortedPhotos;
                    }

                    // Download each file and add to zip
                    for (let i = 0; i < photosToDownload.length; i++) {
                        const photo = photosToDownload[i];
                        const mediaUrl = photo.isVideo 
                            ? (photo.videoUrl || photo.fullUrl) 
                            : (photo.fullUrl || photo.thumbnail);
                        
                        try {
                            const response = await fetch(`${apiUrl}/api/download?url=${encodeURIComponent(mediaUrl)}`);
                            const blob = await response.blob();
                            const extension = photo.isVideo ? 'mp4' : 'jpg';
                            const filename = `${photo.isVideo ? 'video' : 'photo'}-${i + 1}.${extension}`;
                            zip.file(filename, blob);
                        } catch (err) {
                            console.error(`Failed to download ${photo.id}:`, err);
                        }
                    }

                    // Generate and download zip
                    const content = await zip.generateAsync({ type: 'blob' });
                    const url = URL.createObjectURL(content);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${albumInfo?.name || 'album'}-${type}.zip`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                } catch (err) {
                    console.error('Bulk download failed:', err);
                } finally {
                    setIsDownloading(false);
                }
            };

            const toggleContributor = (contributor) => {
                setSelectedContributors(prev => {
                    const newSet = new Set(prev);
                    if (newSet.has(contributor)) {
                        newSet.delete(contributor);
                    } else {
                        newSet.add(contributor);
                    }
                    return newSet;
                });
            };

            const toggleMediaType = (type) => {
                setSelectedMediaTypes(prev => {
                    const newSet = new Set(prev);
                    if (newSet.has(type)) {
                        newSet.delete(type);
                    } else {
                        newSet.add(type);
                    }
                    return newSet;
                });
            };

            const clearAllFilters = () => {
                setSelectedMediaTypes(new Set());
                setSelectedContributors(new Set());
            };

            const hasActiveFilters = selectedMediaTypes.size > 0 || selectedContributors.size > 0;

            const styles = {
                container: {
                    minHeight: '100vh',
                    display: 'flex',
                    flexDirection: 'column'
                },
                landing: {
                    flex: 1,
                    display: 'flex',
                    flexDirection: 'column',
                    alignItems: 'center',
                    justifyContent: 'flex-start',
                    padding: '2rem',
                    paddingTop: 'max(15vh, 100px)',
                    transition: 'opacity 0.4s ease, transform 0.4s ease'
                },
                title: {
                    fontSize: '2rem',
                    fontWeight: 600,
                    marginBottom: '0.5rem',
                    letterSpacing: '-0.02em'
                },
                subtitle: {
                    fontSize: '1rem',
                    opacity: 0.6,
                    marginBottom: '2.5rem',
                    textAlign: 'center'
                },
                form: {
                    width: '100%',
                    maxWidth: '480px',
                    display: 'flex',
                    flexDirection: 'column',
                    gap: '12px'
                },
                input: {
                    padding: '14px 18px',
                    fontSize: '16px',
                    border: `1px solid ${darkMode ? '#333' : '#d2d2d7'}`,
                    borderRadius: '12px',
                    background: darkMode ? '#1c1c1e' : '#fff',
                    color: darkMode ? '#f5f5f7' : '#1d1d1f',
                    outline: 'none',
                    transition: 'border-color 0.2s, box-shadow 0.2s'
                },
                button: {
                    padding: '14px 24px',
                    fontSize: '16px',
                    fontWeight: 500,
                    border: 'none',
                    borderRadius: '12px',
                    background: '#007aff',
                    color: '#fff',
                    cursor: 'pointer',
                    transition: 'opacity 0.2s, transform 0.1s'
                },
                header: {
                    position: 'sticky',
                    top: 0,
                    zIndex: 100,
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'space-between',
                    padding: '8px 20px',
                    background: darkMode ? 'rgba(0,0,0,0.8)' : 'rgba(255,255,255,0.8)',
                    backdropFilter: 'blur(20px)',
                    WebkitBackdropFilter: 'blur(20px)',
                    borderBottom: `1px solid ${darkMode ? '#333' : '#e5e5e5'}`
                },
                headerLeft: {
                    display: 'flex',
                    flexDirection: 'column'
                },
                albumTitle: {
                    fontSize: '24px',
                    fontWeight: 600,
                    letterSpacing: '-0.01em'
                },
                photoCount: {
                    fontSize: '13px',
                    opacity: 0.6
                },
                themeToggle: {
                    background: 'none',
                    border: 'none',
                    cursor: 'pointer',
                    padding: '8px',
                    borderRadius: '8px',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    color: darkMode ? '#f5f5f7' : '#1d1d1f',
                    transition: 'background 0.2s, color 0.2s'
                },
                grid: {
                    display: 'grid',
                    gridTemplateColumns: `repeat(${columns}, 1fr)`,
                    gap: gridPadding,
                    padding: gridPadding
                },
                photoCard: {
                    position: 'relative',
                    aspectRatio: '1',
                    overflow: 'hidden',
                    cursor: 'pointer',
                    background: darkMode ? '#1c1c1e' : '#f5f5f7'
                },
                photoImage: {
                    width: '100%',
                    height: '100%',
                    objectFit: 'cover',
                    transition: 'transform 0.3s ease'
                },
                videoIndicator: {
                    position: 'absolute',
                    top: '50%',
                    left: '50%',
                    transform: 'translate(-50%, -50%)',
                    background: 'rgba(0,0,0,0.5)',
                    borderRadius: '50%',
                    width: '40px',
                    height: '40px',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    color: '#fff'
                },
                videoDuration: {
                    position: 'absolute',
                    bottom: '6px',
                    right: '6px',
                    background: 'rgba(0,0,0,0.6)',
                    borderRadius: '4px',
                    padding: '2px 6px',
                    fontSize: '11px',
                    fontWeight: 500,
                    color: '#fff',
                    fontVariantNumeric: 'tabular-nums'
                },
                thumbnailDownload: {
                    position: 'absolute',
                    top: '6px',
                    right: '6px',
                    background: 'rgba(0,0,0,0.6)',
                    borderRadius: '6px',
                    padding: '6px',
                    border: 'none',
                    cursor: 'pointer',
                    color: '#fff',
                    opacity: 0,
                    transition: 'opacity 0.2s, color 0.2s',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center'
                },
                zoomControls: {
                    display: 'flex',
                    alignItems: 'center',
                    gap: '8px',
                    background: darkMode ? 'rgba(28,28,30,0.9)' : 'rgba(255,255,255,0.9)',
                    backdropFilter: 'blur(20px)',
                    WebkitBackdropFilter: 'blur(20px)',
                    padding: '8px 12px',
                    borderRadius: '9999px',
                    boxShadow: '0 2px 20px rgba(0,0,0,0.15)',
                    border: `1px solid ${darkMode ? '#333' : '#e5e5e5'}`
                },
                zoomButton: {
                    background: 'none',
                    border: 'none',
                    cursor: 'pointer',
                    padding: '4px',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    color: darkMode ? '#f5f5f7' : '#1d1d1f',
                    transition: 'color 0.2s'
                },
                sortControls: {
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    background: darkMode ? 'rgba(28,28,30,0.9)' : 'rgba(255,255,255,0.9)',
                    backdropFilter: 'blur(20px)',
                    WebkitBackdropFilter: 'blur(20px)',
                    padding: '10px',
                    borderRadius: '50%',
                    boxShadow: '0 2px 20px rgba(0,0,0,0.15)',
                    border: `1px solid ${darkMode ? '#333' : '#e5e5e5'}`,
                    width: '40px',
                    height: '40px',
                    color: darkMode ? '#f5f5f7' : '#1d1d1f',
                    transition: 'color 0.2s'
                },
                slider: {
                    width: '80px',
                    background: darkMode ? '#444' : '#d2d2d7'
                },
                overlay: {
                    position: 'fixed',
                    top: 0,
                    left: 0,
                    right: 0,
                    bottom: 0,
                    background: darkMode ? 'rgba(0,0,0,0.95)' : 'rgba(255,255,255,0.95)',
                    zIndex: 1000,
                    display: 'flex',
                    flexDirection: 'column',
                    alignItems: 'center',
                    justifyContent: 'center'
                },
                overlayHeader: {
                    position: 'absolute',
                    top: 0,
                    left: 0,
                    right: 0,
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'space-between',
                    padding: '16px 20px',
                    background: 'transparent'
                },
                backButton: {
                    background: 'none',
                    border: 'none',
                    cursor: 'pointer',
                    padding: '8px',
                    display: 'flex',
                    alignItems: 'center',
                    gap: '6px',
                    color: '#007aff',
                    fontSize: '17px'
                },
                downloadButton: {
                    background: 'none',
                    border: 'none',
                    cursor: 'pointer',
                    padding: '8px',
                    color: '#007aff'
                },
                overlayImage: {
                    position: 'absolute',
                    top: '50%',
                    left: '50%',
                    transform: 'translate(-50%, -50%)',
                    maxWidth: '90vw',
                    maxHeight: '85vh',
                    objectFit: 'contain'
                },
                overlayPlaceholder: {
                    position: 'absolute',
                    top: '50%',
                    left: '50%',
                    transform: 'translate(-50%, -50%)',
                    background: darkMode ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center'
                },
                loadingIndicator: {
                    color: darkMode ? 'rgba(255,255,255,0.4)' : 'rgba(0,0,0,0.4)'
                },
                downloadMenuContainer: {
                    position: 'relative'
                },
                downloadButton: {
                    background: 'none',
                    border: 'none',
                    cursor: 'pointer',
                    padding: '8px',
                    borderRadius: '8px',
                    display: 'flex',
                    alignItems: 'center',
                    gap: '4px',
                    color: darkMode ? '#f5f5f7' : '#1d1d1f',
                    transition: 'background 0.2s, color 0.2s',
                    fontSize: '14px',
                    fontWeight: 500
                },
                downloadMenu: {
                    position: 'absolute',
                    top: 'calc(100% + 4px)',
                    right: 0,
                    background: darkMode ? '#1c1c1e' : '#fff',
                    borderRadius: '8px',
                    boxShadow: '0 4px 12px rgba(0,0,0,0.15)',
                    border: `1px solid ${darkMode ? '#333' : '#e5e5e5'}`,
                    minWidth: '220px',
                    overflow: 'hidden',
                    zIndex: 100
                },
                downloadMenuItem: {
                    padding: '10px 16px',
                    cursor: 'pointer',
                    background: 'transparent',
                    border: 'none',
                    width: '100%',
                    textAlign: 'left',
                    fontSize: '14px',
                    color: darkMode ? '#f5f5f7' : '#1d1d1f',
                    transition: 'background 0.2s, color 0.2s',
                    display: 'flex',
                    alignItems: 'center',
                    gap: '8px'
                },
                downloadCount: {
                    opacity: 0.7,
                    fontSize: '13px'
                },
                error: {
                    color: '#ff3b30',
                    marginTop: '1rem',
                    fontSize: '14px'
                },
                filterMenuContainer: {
                    position: 'relative'
                },
                filterButton: {
                    background: 'none',
                    border: 'none',
                    cursor: 'pointer',
                    padding: '8px',
                    borderRadius: '8px',
                    display: 'flex',
                    alignItems: 'center',
                    gap: '4px',
                    color: darkMode ? '#f5f5f7' : '#1d1d1f',
                    transition: 'background 0.2s, color 0.2s',
                    fontSize: '14px',
                    fontWeight: 500
                },
                filterMenu: {
                    position: 'absolute',
                    bottom: 'calc(100% + 8px)',
                    right: 0,
                    background: darkMode ? '#1c1c1e' : '#fff',
                    borderRadius: '12px',
                    boxShadow: '0 4px 20px rgba(0,0,0,0.2)',
                    border: `1px solid ${darkMode ? '#333' : '#e5e5e5'}`,
                    minWidth: '240px',
                    overflow: 'hidden',
                    zIndex: 100
                },
                filterSection: {
                    borderBottom: `1px solid ${darkMode ? '#333' : '#e5e5e5'}`
                },
                filterSectionTitle: {
                    padding: '12px 16px 8px',
                    fontSize: '11px',
                    fontWeight: 600,
                    textTransform: 'uppercase',
                    opacity: 0.6,
                    letterSpacing: '0.5px'
                },
                filterOption: {
                    padding: '10px 16px',
                    cursor: 'pointer',
                    background: 'transparent',
                    border: 'none',
                    width: '100%',
                    textAlign: 'left',
                    fontSize: '14px',
                    color: darkMode ? '#f5f5f7' : '#1d1d1f',
                    transition: 'background 0.2s, color 0.2s',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'space-between',
                    gap: '8px'
                },
                filterOptionText: {
                    display: 'flex',
                    alignItems: 'center',
                    gap: '8px'
                },
                contributorList: {
                    maxHeight: '200px',
                    overflowY: 'auto'
                },
                activeFilterBadge: {
                    position: 'absolute',
                    top: '4px',
                    right: '4px',
                    width: '8px',
                    height: '8px',
                    borderRadius: '50%',
                    background: '#007aff'
                }
            };

            // Skeleton grid for loading
            const SkeletonGrid = () => (
                <div style={styles.grid}>
                    {Array.from({ length: columns * 4 }).map((_, i) => (
                        <div key={i} style={styles.photoCard} className="skeleton" />
                    ))}
                </div>
            );

            return (
                <div style={styles.container}>
                    {/* Landing Page */}
                    {showLanding && (
                        <div style={styles.landing} className={showLanding ? '' : 'fade-out'}>
                            <svg id="Layer_1" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 476.67 310" style={{ width: '120px', height: 'auto', marginBottom: '20px' }}>
                                <defs>
                                    <style>
                                        {`.cls-1 {
                                            fill: none;
                                            stroke: ${darkMode ? '#f5f5f7' : '#000'};
                                            stroke-miterlimit: 10;
                                            stroke-width: 10px;
                                        }`}
                                    </style>
                                </defs>
                                <path className="cls-1" d="M399.04,126.78c37.36,9.05,72.62,42.73,72.62,90.35s-45.42,87.87-87.14,87.87H94.69c-42.85,0-89.69-45.41-89.69-91.39s23.58-75.87,58.24-92.1c12.6-59.46,65.7-63.72,98.39-52.65,20.19-31.75,58.76-63.86,110.83-63.86,71.45,0,121.59,59.54,126.58,121.78Z"/>
                            </svg>
                            <h1 style={styles.title}>iCloud Album Viewer</h1>
                            <p style={styles.subtitle}>
                                Paste a shared iCloud album link or hash token to view photos and videos
                            </p>
                            <form onSubmit={handleSubmit} style={styles.form}>
                                <input
                                    type="text"
                                    value={albumUrl}
                                    onChange={(e) => setAlbumUrl(e.target.value)}
                                    placeholder="https://www.icloud.com/sharedalbum/#..."
                                    style={styles.input}
                                />
                                <button 
                                    type="submit" 
                                    style={{
                                        ...styles.button,
                                        opacity: albumUrl.trim() ? 1 : 0.5,
                                        cursor: albumUrl.trim() ? 'pointer' : 'not-allowed'
                                    }}
                                    disabled={!albumUrl.trim()}
                                >
                                    View Album
                                </button>
                            </form>
                            {error && <p style={styles.error}>{error}</p>}
                        </div>
                    )}

                    {/* Album View */}
                    {!showLanding && (
                        <>
                            {/* Sticky Header */}
                            <header style={styles.header}>
                                <div style={styles.headerLeft}>
                                    <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                                        <span style={styles.albumTitle}>
                                            {loading ? (
                                                <span>iCloud Album Loading<span className="loading-dots"><span>.</span><span>.</span><span>.</span></span></span>
                                            ) : (
                                                albumInfo?.name || 'Shared Album'
                                            )}
                                        </span>
                                        {!loading && albumInfo && (
                                            <button
                                                style={{
                                                    background: 'none',
                                                    border: 'none',
                                                    cursor: 'pointer',
                                                    padding: '4px',
                                                    display: 'flex',
                                                    alignItems: 'center',
                                                    color: darkMode ? '#f5f5f7' : '#1d1d1f',
                                                    transition: 'color 0.2s'
                                                }}
                                                onMouseEnter={(e) => e.currentTarget.style.color = '#007aff'}
                                                onMouseLeave={(e) => e.currentTarget.style.color = darkMode ? '#f5f5f7' : '#1d1d1f'}
                                                onClick={copyUrlToClipboard}
                                                title="Copy shareable link"
                                            >
                                                <ExternalLink size={18} />
                                            </button>
                                        )}
                                        {copiedUrl && (
                                            <span style={{
                                                fontSize: '14px',
                                                color: '#007aff',
                                                fontWeight: 500
                                            }}>
                                                Link copied!
                                            </span>
                                        )}
                                    </div>
                                    <span style={styles.photoCount}>
                                        {!loading && albumInfo ? (
                                            <>
                                                {albumInfo.photoCount > 0 && `${albumInfo.photoCount} photo${albumInfo.photoCount !== 1 ? 's' : ''}`}
                                                {albumInfo.photoCount > 0 && albumInfo.videoCount > 0 && ', '}
                                                {albumInfo.videoCount > 0 && `${albumInfo.videoCount} video${albumInfo.videoCount !== 1 ? 's' : ''}`}
                                            </>
                                        ) : ''}
                                    </span>
                                </div>
                                <div style={{ display: 'flex', alignItems: 'center', gap: '4px' }}>
                                    <div style={styles.downloadMenuContainer} ref={downloadMenuRef}>
                                        <button 
                                            style={styles.downloadButton}
                                            onClick={() => setShowDownloadMenu(!showDownloadMenu)}
                                            onMouseEnter={(e) => e.currentTarget.style.color = '#007aff'}
                                            onMouseLeave={(e) => e.currentTarget.style.color = darkMode ? '#f5f5f7' : '#1d1d1f'}
                                            title="Download options"
                                            disabled={isDownloading}
                                        >
                                            {isDownloading ? (
                                                <>
                                                    <div className="loading-dots">
                                                        <span>.</span>
                                                        <span>.</span>
                                                        <span>.</span>
                                                    </div>
                                                </>
                                            ) : (
                                                <Download size={20} />
                                            )}
                                        </button>
                                        {showDownloadMenu && !isDownloading && (
                                            <div style={styles.downloadMenu}>
                                                <button 
                                                    className="download-menu-item"
                                                    style={styles.downloadMenuItem}
                                                    onClick={() => downloadBulk('images')}
                                                    onMouseEnter={(e) => e.currentTarget.style.color = '#007aff'}
                                                    onMouseLeave={(e) => e.currentTarget.style.color = darkMode ? '#f5f5f7' : '#1d1d1f'}
                                                >
                                                    <Camera size={20} />
                                                    <span>
                                                        Download Images{' '}
                                                        <span style={styles.downloadCount}>({imageCount})</span>
                                                    </span>
                                                </button>
                                                <button 
                                                    className="download-menu-item"
                                                    style={styles.downloadMenuItem}
                                                    onClick={() => downloadBulk('videos')}
                                                    onMouseEnter={(e) => e.currentTarget.style.color = '#007aff'}
                                                    onMouseLeave={(e) => e.currentTarget.style.color = darkMode ? '#f5f5f7' : '#1d1d1f'}
                                                >
                                                    <Video size={20} />
                                                    <span>
                                                        Download Videos{' '}
                                                        <span style={styles.downloadCount}>({videoCount})</span>
                                                    </span>
                                                </button>
                                                <button 
                                                    className="download-menu-item"
                                                    style={styles.downloadMenuItem}
                                                    onClick={() => downloadBulk('all')}
                                                    onMouseEnter={(e) => e.currentTarget.style.color = '#007aff'}
                                                    onMouseLeave={(e) => e.currentTarget.style.color = darkMode ? '#f5f5f7' : '#1d1d1f'}
                                                >
                                                    <Server size={20} />
                                                    <span>
                                                        Download All{' '}
                                                        <span style={styles.downloadCount}>({sortedPhotos.length})</span>
                                                    </span>
                                                </button>
                                            </div>
                                        )}
                                    </div>
                                    <button 
                                        style={styles.themeToggle}
                                        onClick={() => setDarkMode(!darkMode)}
                                        onMouseEnter={(e) => e.currentTarget.style.color = '#007aff'}
                                        onMouseLeave={(e) => e.currentTarget.style.color = darkMode ? '#f5f5f7' : '#1d1d1f'}
                                        title={darkMode ? 'Light mode' : 'Dark mode'}
                                    >
                                        {darkMode ? <Sun size={20} /> : <Moon size={20} />}
                                    </button>
                                </div>
                            </header>

                            {/* Photo Grid or Skeleton */}
                            {loading ? (
                                <SkeletonGrid />
                            ) : (
                                <div style={styles.grid}>
                                    {sortedPhotos.map((photo) => (
                                        <div 
                                            key={photo.id}
                                            className="photo-card"
                                            style={styles.photoCard}
                                            onClick={() => setSelectedPhoto(photo)}
                                        >
                                            {!loadedPhotos[photo.id] && (
                                                <div 
                                                    className="skeleton" 
                                                    style={{ 
                                                        position: 'absolute', 
                                                        inset: 0 
                                                    }} 
                                                />
                                            )}
                                            <img
                                                src={photo.thumbnail}
                                                alt={photo.caption || ''}
                                                style={{
                                                    ...styles.photoImage,
                                                    opacity: loadedPhotos[photo.id] ? 1 : 0
                                                }}
                                                onLoad={() => handleImageLoad(photo.id)}
                                            />
                                            {loadedPhotos[photo.id] && (
                                                <button
                                                    className="thumbnail-download"
                                                    style={styles.thumbnailDownload}
                                                    onClick={(e) => downloadImage(photo, e)}
                                                    onMouseEnter={(e) => e.currentTarget.style.color = '#007aff'}
                                                    onMouseLeave={(e) => e.currentTarget.style.color = '#fff'}
                                                    title="Download"
                                                >
                                                    <Download size={14} />
                                                </button>
                                            )}
                                            {photo.isVideo && loadedPhotos[photo.id] && (
                                                <div style={styles.videoIndicator}>
                                                    <Play size={16} />
                                                </div>
                                            )}
                                            {photo.isVideo && videoDurations[photo.id] && loadedPhotos[photo.id] && squareSize >= 48 && (
                                                <div style={styles.videoDuration}>
                                                    {formatDuration(videoDurations[photo.id])}
                                                </div>
                                            )}
                                        </div>
                                    ))}
                                </div>
                            )}

                            {/* Zoom and Sort Controls */}
                            {!loading && sortedPhotos.length > 0 && (
                                <div style={{
                                    position: 'fixed',
                                    bottom: '20px',
                                    right: '20px',
                                    display: 'flex',
                                    alignItems: 'center',
                                    gap: '8px'
                                }}>
                                    {/* Filter Menu */}
                                    <div style={styles.filterMenuContainer} ref={filterMenuRef}>
                                        <button 
                                            style={{
                                                ...styles.sortControls,
                                                position: 'relative',
                                                cursor: 'pointer'
                                            }}
                                            onClick={() => setShowFilterMenu(!showFilterMenu)}
                                            onMouseEnter={(e) => e.currentTarget.style.color = '#007aff'}
                                            onMouseLeave={(e) => e.currentTarget.style.color = darkMode ? '#f5f5f7' : '#1d1d1f'}
                                            title="Filter photos"
                                        >
                                            <ListFilter size={18} />
                                            {hasActiveFilters && <div style={styles.activeFilterBadge} />}
                                        </button>
                                        {showFilterMenu && (
                                            <div style={styles.filterMenu}>
                                                {/* Media Type Filter */}
                                                <div style={styles.filterSection}>
                                                    <div style={styles.filterSectionTitle}>
                                                        Media Type
                                                        {selectedMediaTypes.size > 0 && ` (${selectedMediaTypes.size})`}
                                                    </div>
                                                    <button
                                                        style={{
                                                            ...styles.filterOption,
                                                            opacity: imageCount === 0 ? 0.4 : 1,
                                                            cursor: imageCount === 0 ? 'not-allowed' : 'pointer'
                                                        }}
                                                        onClick={() => imageCount > 0 && toggleMediaType('images')}
                                                        onMouseEnter={(e) => {
                                                            if (imageCount > 0) {
                                                                e.currentTarget.style.background = 'rgba(0, 122, 255, 0.1)';
                                                                e.currentTarget.style.color = '#007aff';
                                                            }
                                                        }}
                                                        onMouseLeave={(e) => {
                                                            e.currentTarget.style.background = 'transparent';
                                                            e.currentTarget.style.color = darkMode ? '#f5f5f7' : '#1d1d1f';
                                                        }}
                                                        disabled={imageCount === 0}
                                                    >
                                                        <span style={styles.filterOptionText}>
                                                            <Camera size={16} />
                                                            Images
                                                        </span>
                                                        {selectedMediaTypes.has('images') && <Check size={16} />}
                                                    </button>
                                                    <button
                                                        style={{
                                                            ...styles.filterOption,
                                                            opacity: videoCount === 0 ? 0.4 : 1,
                                                            cursor: videoCount === 0 ? 'not-allowed' : 'pointer'
                                                        }}
                                                        onClick={() => videoCount > 0 && toggleMediaType('videos')}
                                                        onMouseEnter={(e) => {
                                                            if (videoCount > 0) {
                                                                e.currentTarget.style.background = 'rgba(0, 122, 255, 0.1)';
                                                                e.currentTarget.style.color = '#007aff';
                                                            }
                                                        }}
                                                        onMouseLeave={(e) => {
                                                            e.currentTarget.style.background = 'transparent';
                                                            e.currentTarget.style.color = darkMode ? '#f5f5f7' : '#1d1d1f';
                                                        }}
                                                        disabled={videoCount === 0}
                                                    >
                                                        <span style={styles.filterOptionText}>
                                                            <Video size={16} />
                                                            Videos
                                                        </span>
                                                        {selectedMediaTypes.has('videos') && <Check size={16} />}
                                                    </button>
                                                </div>

                                                {/* Contributors Filter */}
                                                {contributors.length > 0 && (
                                                    <div style={styles.filterSection}>
                                                        <div style={styles.filterSectionTitle}>
                                                            Contributors
                                                            {selectedContributors.size > 0 && ` (${selectedContributors.size})`}
                                                        </div>
                                                        <div style={styles.contributorList}>
                                                            {contributors.map(contributor => (
                                                                <button
                                                                    key={contributor}
                                                                    style={styles.filterOption}
                                                                    onClick={() => toggleContributor(contributor)}
                                                                    onMouseEnter={(e) => {
                                                                        e.currentTarget.style.background = 'rgba(0, 122, 255, 0.1)';
                                                                        e.currentTarget.style.color = '#007aff';
                                                                    }}
                                                                    onMouseLeave={(e) => {
                                                                        e.currentTarget.style.background = 'transparent';
                                                                        e.currentTarget.style.color = darkMode ? '#f5f5f7' : '#1d1d1f';
                                                                    }}
                                                                >
                                                                    <span style={styles.filterOptionText}>
                                                                        <Users size={16} />
                                                                        {contributor}
                                                                    </span>
                                                                    {selectedContributors.has(contributor) && <Check size={16} />}
                                                                </button>
                                                            ))}
                                                        </div>
                                                    </div>
                                                )}

                                                {/* Clear All Button */}
                                                {hasActiveFilters && (
                                                    <div style={{ padding: '8px' }}>
                                                        <button
                                                            style={{
                                                                ...styles.filterOption,
                                                                color: '#007aff',
                                                                fontWeight: 500,
                                                                justifyContent: 'center'
                                                            }}
                                                            onClick={clearAllFilters}
                                                            onMouseEnter={(e) => {
                                                                e.currentTarget.style.background = 'rgba(0, 122, 255, 0.1)';
                                                            }}
                                                            onMouseLeave={(e) => {
                                                                e.currentTarget.style.background = 'transparent';
                                                            }}
                                                        >
                                                            Clear All Filters
                                                        </button>
                                                    </div>
                                                )}
                                            </div>
                                        )}
                                    </div>
                                    <div style={styles.sortControls}>
                                        <button 
                                            style={styles.zoomButton}
                                            onClick={() => setSortOrder(s => s === 'newest' ? 'oldest' : 'newest')}
                                            onMouseEnter={(e) => e.currentTarget.style.color = '#007aff'}
                                            onMouseLeave={(e) => e.currentTarget.style.color = darkMode ? '#f5f5f7' : '#1d1d1f'}
                                            title={sortOrder === 'newest' ? 'Showing newest first' : 'Showing oldest first'}
                                        >
                                            {sortOrder === 'newest' ? <CalendarArrowDown size={18} /> : <CalendarArrowUp size={18} />}
                                        </button>
                                    </div>
                                    <div style={styles.zoomControls}>
                                        <button 
                                            style={styles.zoomButton}
                                            onClick={() => setColumns(c => Math.min(c + 1, 20))}
                                            onMouseEnter={(e) => e.currentTarget.style.color = '#007aff'}
                                            onMouseLeave={(e) => e.currentTarget.style.color = darkMode ? '#f5f5f7' : '#1d1d1f'}
                                            title="Smaller"
                                        >
                                            <Minus size={18} />
                                        </button>
                                        <input
                                            type="range"
                                            min="2"
                                            max="20"
                                            value={22 - columns}
                                            onChange={(e) => setColumns(22 - parseInt(e.target.value))}
                                            style={styles.slider}
                                        />
                                        <button 
                                            style={styles.zoomButton}
                                            onClick={() => setColumns(c => Math.max(c - 1, 2))}
                                            onMouseEnter={(e) => e.currentTarget.style.color = '#007aff'}
                                            onMouseLeave={(e) => e.currentTarget.style.color = darkMode ? '#f5f5f7' : '#1d1d1f'}
                                            title="Larger"
                                        >
                                            <Plus size={18} />
                                        </button>
                                    </div>
                                </div>
                            )}
                        </>
                    )}

                    {/* Full Image/Video Overlay */}
                    {selectedPhoto && (
                        <div style={styles.overlay} className="fade-in">
                            <div style={styles.overlayHeader}>
                                <button 
                                    style={styles.backButton}
                                    onClick={() => setSelectedPhoto(null)}
                                >
                                    <ArrowLeft size={20} />
                                    <span>Back</span>
                                </button>
                                <button
                                    style={styles.downloadButton}
                                    onClick={(e) => downloadImage(selectedPhoto, e)}
                                    onMouseEnter={(e) => e.currentTarget.style.color = '#007aff'}
                                    onMouseLeave={(e) => e.currentTarget.style.color = darkMode ? '#f5f5f7' : '#1d1d1f'}
                                    title="Download"
                                >
                                    <Download size={22} />
                                </button>
                            </div>
                            
                            {/* Previous photo - swiping out */}
                            {previousPhoto && swipeDirection && (
                                <>
                                    {!overlayLoadedPhotos[previousPhoto.id] && (
                                        <div 
                                            style={{
                                                ...styles.overlayPlaceholder,
                                                ...getPlaceholderDimensions(previousPhoto)
                                            }}
                                            className={swipeDirection === 'left' ? 'swipe-out-left' : 'swipe-out-right'}
                                        >
                                            <div style={styles.loadingIndicator} className="loading-spinner">
                                                <span></span>
                                                <span></span>
                                                <span></span>
                                                <span></span>
                                                <span></span>
                                                <span></span>
                                                <span></span>
                                                <span></span>
                                            </div>
                                        </div>
                                    )}
                                    {previousPhoto.isVideo ? (
                                        <video
                                            key={`prev-${previousPhoto.id}`}
                                            src={previousPhoto.videoUrl || previousPhoto.fullUrl}
                                            style={{
                                                ...styles.overlayImage,
                                                display: overlayLoadedPhotos[previousPhoto.id] ? 'block' : 'none'
                                            }}
                                            className={swipeDirection === 'left' ? 'swipe-out-left' : 'swipe-out-right'}
                                            controls
                                            playsInline
                                            onLoadedData={() => handleOverlayImageLoad(previousPhoto.id)}
                                        />
                                    ) : (
                                        <img
                                            key={`prev-${previousPhoto.id}`}
                                            src={previousPhoto.fullUrl || previousPhoto.thumbnail}
                                            alt={previousPhoto.caption || ''}
                                            style={{
                                                ...styles.overlayImage,
                                                opacity: overlayLoadedPhotos[previousPhoto.id] ? 1 : 0
                                            }}
                                            className={swipeDirection === 'left' ? 'swipe-out-left' : 'swipe-out-right'}
                                            onLoad={() => handleOverlayImageLoad(previousPhoto.id)}
                                        />
                                    )}
                                </>
                            )}
                            
                            {/* Current photo - swiping in or static */}
                            {!overlayLoadedPhotos[selectedPhoto.id] && (
                                <div 
                                    style={{
                                        ...styles.overlayPlaceholder,
                                        // Use current photo's aspect ratio, or fallback to previous photo's if swiping
                                        ...getPlaceholderDimensions(
                                            selectedPhoto.width && selectedPhoto.height 
                                                ? selectedPhoto 
                                                : (swipeDirection && previousPhoto ? previousPhoto : selectedPhoto)
                                        )
                                    }}
                                    className={
                                        swipeDirection === 'left' ? 'swipe-in-from-right' :
                                        swipeDirection === 'right' ? 'swipe-in-from-left' : 
                                        isOpeningFromGrid ? 'scale-in' : ''
                                    }
                                >
                                    <div style={styles.loadingIndicator} className="loading-spinner">
                                        <span></span>
                                        <span></span>
                                        <span></span>
                                        <span></span>
                                        <span></span>
                                        <span></span>
                                        <span></span>
                                        <span></span>
                                    </div>
                                </div>
                            )}
                            {selectedPhoto.isVideo ? (
                                <video
                                    ref={videoRef}
                                    key={`current-${selectedPhoto.id}`}
                                    src={selectedPhoto.videoUrl || selectedPhoto.fullUrl}
                                    style={{
                                        ...styles.overlayImage,
                                        display: overlayLoadedPhotos[selectedPhoto.id] ? 'block' : 'none'
                                    }}
                                    className={
                                        swipeDirection === 'left' ? 'swipe-in-from-right' :
                                        swipeDirection === 'right' ? 'swipe-in-from-left' : 
                                        isOpeningFromGrid ? 'scale-in' : ''
                                    }
                                    controls
                                    playsInline
                                    onLoadedData={() => handleOverlayImageLoad(selectedPhoto.id)}
                                />
                            ) : (
                                <img
                                    key={`current-${selectedPhoto.id}`}
                                    src={selectedPhoto.fullUrl || selectedPhoto.thumbnail}
                                    alt={selectedPhoto.caption || ''}
                                    style={{
                                        ...styles.overlayImage,
                                        opacity: overlayLoadedPhotos[selectedPhoto.id] ? 1 : 0
                                    }}
                                    className={
                                        swipeDirection === 'left' ? 'swipe-in-from-right' :
                                        swipeDirection === 'right' ? 'swipe-in-from-left' : 
                                        isOpeningFromGrid ? 'scale-in' : ''
                                    }
                                    onLoad={() => handleOverlayImageLoad(selectedPhoto.id)}
                                />
                            )}
                        </div>
                    )}
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<ICloudAlbumViewer />);
    </script>
</body>
</html>